<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BBox Viewer</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #f0f0f0;
        }
        
        bbox-viewer-app {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        #error-message {
            display: none;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 3;
            font-family: Arial, sans-serif;
            min-width: 400px;
        }
        
        #error-message.error {
            background: none;
            padding: 20px;
        }
        
        #error-message.neutral {
            background: none;
            box-shadow: none;
            padding: 20px;
        }
        
        #error-message h1 {
            color: #d32f2f;
            margin: 0 0 20px 0;
            font-size: 28px;
        }
        
        #error-message .error-path {
            color: #666;
            font-size: 14px;
            word-break: break-all;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px;
            border-radius: 4px;
            display: inline-block;
        }
        
        #error-message h2 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 20px;
        }
        
        #error-message.error h2 {
            color: #d32f2f;
        }
        
        #error-message.neutral h2 {
            color: #333;
            display: block !important;
            margin-bottom: 30px;
            font-size: 24px;
        }
        
        #error-text {
            color: #666;
            margin: 10px 0;
            font-size: 14px;
        }
        
        #error-details {
            background: #fff;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-family: monospace;
            white-space: pre-wrap;
            text-align: left;
            font-size: 12px;
            color: #666;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .mapping-info {
            margin-top: 0;
            color: #666;
            text-align: left;
            padding: 0;
            font-size: 13px;
            background: none;
            box-shadow: none;
        }
        
        .mapping-info h4 {
            color: #888;
            font-size: 14px;
            margin: 0 0 15px 0;
            font-weight: normal;
        }
        
        .base-path-info {
            color: #888;
            font-size: 12px;
            margin-top: 15px;
            text-align: left;
        }
        
        .mapping-toggle {
            display: none;
        }
        
        .mapping-details {
            display: table !important;
            margin-top: 0;
            border-spacing: 0;
            width: 100%;
            background: none;
            border-radius: 0;
            box-shadow: none;
        }
        
        .mapping-row {
            display: table-row;
        }
        
        .mapping-row:nth-child(even) {
            background: none;
        }
        
        .mapping-label {
            display: table-cell;
            padding: 6px 0;
            font-weight: 500;
            color: #888;
            width: 60px;
            white-space: nowrap;
            font-size: 12px;
        }
        
        .mapping-description {
            display: table-cell;
            padding: 6px 0 6px 12px;
            color: #888;
            font-size: 12px;
        }
        
        .view-control {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 50px;
            height: 50px;
            cursor: pointer;
        }
        .view-control:hover {
            opacity: 0.5;
        }
        .view-control:active {
            transform: scale(0.9);
        }
        .view-control img {
            width: 30px;
            height: 30px;
            margin: 0 5px;
        }
        #toolbar {
            height: 50px;
            background-color: white;
            border-top: 2px solid #ddd;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1;
        }
        #toolbar.hidden {
            display: none;
        }
        #zoom-slider {
            width: 100px;
            opacity: 0.7;
        }
        #zoom-slider:hover {
            opacity: 1;
        }
    </style>
</head>
<body>
    <bbox-viewer-app></bbox-viewer-app>
    <!-- <div id="debug-panel"></div> -->

    <script>
        class BboxViewerApp extends HTMLElement {
            constructor() {
                super();
                this.attachShadow({ mode: 'open' });
                this.basePath = './images/'; // Base path for images - can be configured
                this.disableInteraction = false; // New property to control interaction
                
                // Define column mapping for easier adjustments
                this.columnMapping = {
                    image: 'image',
                    x: 'x',
                    y: 'y',
                    width: 'width',
                    height: 'height',
                    class: 'class',
                    probability: 'proba',
                    id: 'id'
                };
                
                this.shadowRoot.innerHTML = `
                    <style>
                        :host {
                            display: block;
                            width: 100%;
                            height: 100%;
                            overflow: hidden;
                        }
                        #app-container {
                            width: 100%;
                            height: 100%;
                            display: flex;
                            flex-direction: column;
                            overflow: hidden;
                            background-color: #f8f8f8;
                        }
                        #image-container {
                            flex: 1;
                            position: relative;
                            overflow: hidden;
                            width: 100%;
                            height: 100%;
                        }
                        #image, #overlay {
                            position: absolute;
                            left: 50%;
                            top: 50%;
                            transform-origin: center;
                            max-width: 100%;
                            max-height: 100%;
                        }
                        #overlay {
                            pointer-events: auto;
                            width: 100%;
                            height: 100%;
                            z-index: 2;
                            image-rendering: pixelated;
                            image-rendering: -moz-crisp-edges;
                            image-rendering: -o-crisp-edges;
                            image-rendering: -webkit-optimize-contrast;
                            image-rendering: crisp-edges;
                            -ms-interpolation-mode: nearest-neighbor;
                        }
                        .smooth {
                            transition: transform 0.3s ease;
                        }
                        #error-message {
                            display: none;
                            position: absolute;
                            left: 50%;
                            top: 50%;
                            transform: translate(-50%, -50%);
                            text-align: center;
                            z-index: 3;
                            font-family: Arial, sans-serif;
                            min-width: 400px;
                        }
                        
                        #error-message h1 {
                            color: #d32f2f;
                            margin: 0 0 20px 0;
                            font-size: 28px;
                        }
                        
                        #error-message .error-path {
                            color: #666;
                            font-size: 14px;
                            word-break: break-all;
                            background: rgba(255, 255, 255, 0.9);
                            padding: 8px;
                            border-radius: 4px;
                            display: inline-block;
                        }
                        
                        #error-message.error {
                            background: none;
                            padding: 20px;
                        }
                        
                        #error-message.neutral {
                            background: none;
                            box-shadow: none;
                            padding: 20px;
                        }
                        
                        #error-message h2 {
                            margin-top: 0;
                            margin-bottom: 15px;
                            font-size: 20px;
                        }
                        
                        #error-message.error h2 {
                            color: #d32f2f;
                        }
                        
                        #error-message.neutral h2 {
                            color: #333;
                            display: block !important;
                            margin-bottom: 30px;
                            font-size: 24px;
                        }
                        
                        #error-text {
                            color: #666;
                            margin: 10px 0;
                            font-size: 14px;
                        }
                        
                        #error-details {
                            background: #fff;
                            padding: 10px;
                            border-radius: 4px;
                            margin: 10px 0;
                            font-family: monospace;
                            white-space: pre-wrap;
                            text-align: left;
                            font-size: 12px;
                            color: #666;
                            max-height: 200px;
                            overflow-y: auto;
                        }
                        
                        .mapping-info {
                            margin-top: 0;
                            color: #666;
                            text-align: left;
                            padding: 0;
                            font-size: 13px;
                            background: none;
                            box-shadow: none;
                        }
                        
                        .mapping-info h4 {
                            color: #888;
                            font-size: 14px;
                            margin: 0 0 15px 0;
                            font-weight: normal;
                        }
                        
                        .base-path-info {
                            color: #888;
                            font-size: 12px;
                            margin-top: 15px;
                            text-align: left;
                        }
                        
                        .mapping-details {
                            display: table !important;
                            margin-top: 0;
                            border-spacing: 0;
                            width: 100%;
                            background: none;
                            border-radius: 0;
                            box-shadow: none;
                        }
                        
                        .mapping-row {
                            display: table-row;
                        }
                        
                        .mapping-row:nth-child(even) {
                            background: none;
                        }
                        
                        .mapping-label {
                            display: table-cell;
                            padding: 6px 0;
                            font-weight: 500;
                            color: #888;
                            width: 60px;
                            white-space: nowrap;
                            font-size: 12px;
                        }
                        
                        .mapping-description {
                            display: table-cell;
                            padding: 6px 0 6px 12px;
                            color: #888;
                            font-size: 12px;
                        }
                        
                        .view-control {
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            width: 50px;
                            height: 50px;
                            cursor: pointer;
                        }
                        .view-control:hover {
                            opacity: 0.5;
                        }
                        .view-control:active {
                            transform: scale(0.9);
                        }
                        .view-control img {
                            width: 30px;
                            height: 30px;
                            margin: 0 5px;
                        }
                        #toolbar {
                            height: 50px;
                            background-color: white;
                            border-top: 2px solid #ddd;
                            display: flex;
                            justify-content: center;
                            align-items: center;
                            z-index: 1;
                        }
                        #toolbar.hidden {
                            display: none;
                        }
                        #zoom-slider {
                            width: 100px;
                            opacity: 0.7;
                        }
                        #zoom-slider:hover {
                            opacity: 1;
                        }
                    </style>
                    <div id="app-container">
                        <div id="image-container">
                            <img id="image" src="" alt="Placeholder Image" style="display: none;">
                            <canvas id="overlay"></canvas>
                            <div id="error-message">
                                <div id="mapping-info" class="mapping-info">
                                    <h2>Select an image</h2>
                                    <h4>Expected Variables</h4>
                                    <div class="mapping-details"></div>
                                    <div class="base-path-info">Current base path: ${this.basePath}</div>
                                </div>
                            </div>
                        </div>
                        <div id="toolbar">
                            <div class="view-control"><img id="zoom-out" src="icons/remove-outline.svg" alt="Zoom Out"></div>
                            <input type="range" id="zoom-slider" min="20" max="300" value="100">
                            <div class="view-control"><img id="zoom-in" src="icons/add-outline.svg" alt="Zoom In"></div>
                            <div class="view-control"><img id="maximize" src="icons/expand-outline.svg" alt="Maximize"></div>
                            <div class="view-control"><img id="minimize" src="icons/scan-outline.svg" alt="Minimize"></div>
                        </div>
                    </div>
                `;

                this.zoomLevel = 1;
                this.image = this.shadowRoot.querySelector('#image');
                this.canvas = this.shadowRoot.querySelector('#overlay');
                this.imageContainer = this.shadowRoot.querySelector('#image-container');
                this.zoomInButton = this.shadowRoot.querySelector('#zoom-in');
                this.zoomOutButton = this.shadowRoot.querySelector('#zoom-out');
                this.zoomSlider = this.shadowRoot.querySelector('#zoom-slider');
                this.maximizeButton = this.shadowRoot.querySelector('#maximize');
                this.minimizeButton = this.shadowRoot.querySelector('#minimize');
                this.debugPanel = document.querySelector('#debug-panel');
                this.errorMessage = this.shadowRoot.querySelector('#error-message');
                this.errorText = this.shadowRoot.querySelector('#error-text');
                this.errorDetails = this.shadowRoot.querySelector('#error-details');

                this.imageX = 0;
                this.imageY = 0;
                this.isDragging = false;
                this.startX = 0;
                this.startY = 0;

                // Apply initial toolbar visibility based on disableInteraction
                if (this.disableInteraction) {
                    this.shadowRoot.querySelector('#toolbar').classList.add('hidden');
                }

                // Color mapping system
                this.colorCache = new Map();
                // Predefined colors for common classes (like in skeleton example)
                this.predefinedColors = {
                    'person': 'rgb(31, 119, 180)',  // Blue
                    'car': 'rgb(255, 127, 14)',     // Orange
                    'dog': 'rgb(44, 160, 44)',      // Green
                    'cat': 'rgb(214, 39, 40)',      // Red
                    'bicycle': 'rgb(148, 103, 189)', // Purple
                    'motorcycle': 'rgb(140, 86, 75)', // Brown
                };
                // Additional distinct colors for unknown classes
                this.fallbackColors = [
                    'rgb(227, 119, 194)', // Pink
                    'rgb(127, 127, 127)', // Gray
                    'rgb(188, 189, 34)',  // Yellow-green
                    'rgb(23, 190, 207)',  // Cyan
                    'rgb(141, 211, 199)', // Light blue-green
                    'rgb(255, 255, 179)', // Light yellow
                    'rgb(190, 186, 218)', // Light purple
                    'rgb(251, 128, 114)', // Salmon
                    'rgb(128, 177, 211)', // Steel blue
                    'rgb(253, 180, 98)',  // Light orange
                ];
                this.nextFallbackColorIndex = 0;

                // Initialize empty rectangles array
                this.rectangles = [];

                // Store the original image dimensions when image loads
                this.image.addEventListener('load', () => {
                    this.originalImageWidth = this.image.naturalWidth;
                    this.originalImageHeight = this.image.naturalHeight;
                    this.updateCanvasSize();
                });
                
                this.zoomInButton.addEventListener('click', () => this.zoomIn());
                this.zoomOutButton.addEventListener('click', () => this.zoomOut());
                this.zoomSlider.addEventListener('input', () => this.sliderZoom());
                this.maximizeButton.addEventListener('click', () => this.maximize());
                this.minimizeButton.addEventListener('click', () => this.minimize());
                this.image.addEventListener('load', () => this.updateCanvasSize());
                this.imageContainer.addEventListener('mousedown', (e) => this.startDrag(e));
                this.imageContainer.addEventListener('mousemove', (e) => this.drag(e));
                this.imageContainer.addEventListener('mouseup', () => this.endDrag());
                this.imageContainer.addEventListener('mouseleave', () => this.endDrag());
                this.imageContainer.addEventListener('wheel', (e) => this.handleWheel(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleCanvasHover(e));

                // Add message event listener for VA data
                if (window.addEventListener) {
                    window.addEventListener("message", (event) => this.onMessage(event), false);
                } else {
                    window.attachEvent("onmessage", (event) => this.onMessage(event));
                }

                this.updateDebugPanel();

                // Add ResizeObserver to handle window resizing
                this.resizeObserver = new ResizeObserver(() => {
                    this.updateCanvasSize();
                });
                this.resizeObserver.observe(this.imageContainer);

                // Add click handler for mapping toggle
                this.shadowRoot.querySelector('.mapping-toggle').addEventListener('click', (e) => {
                    const details = this.shadowRoot.querySelector('.mapping-details');
                    const toggle = e.target;
                    if (details.classList.contains('show')) {
                        details.classList.remove('show');
                        toggle.textContent = 'Show expected data format ▼';
                    } else {
                        details.classList.add('show');
                        toggle.textContent = 'Hide expected data format ▲';
                    }
                });

                // Initialize mapping explanations
                this.updateMappingExplanations();
            }

            // Displays an error message and hides the image
            showError(message, details = '', type = 'error') {
                this.errorMessage.style.display = 'block';
                this.image.style.display = 'none';
                
                // Reset classes and apply the appropriate one
                this.errorMessage.classList.remove('error', 'neutral');
                this.errorMessage.classList.add(type);
                
                const mappingInfo = this.shadowRoot.querySelector('#mapping-info');
                
                if (type === 'error') {
                    // For error messages, show error state
                    mappingInfo.style.display = 'none';
                    this.errorMessage.innerHTML = `
                        <h1>${message}</h1>
                        <div class="error-path">${details}</div>
                    `;
                } else {
                    // For neutral messages (like no selection), show mapping info
                    mappingInfo.style.display = 'block';
                    this.updateMappingExplanations();
                }
                
                this.rectangles = [];
                this.drawRectangles();
            }

            // Handles incoming data from VA and processes it for display
            onMessage(event) {
                if (!event || !event.data) return;
                
                const vaData = event.data;
                
                if (!vaData.data || !Array.isArray(vaData.data) || vaData.data.length === 0 || !vaData.columns) {
                    this.showError("Invalid data format received");
                    return;
                }

                // Create a map of column labels to indices
                const columnIndices = {};
                vaData.columns.forEach((col, index) => {
                    columnIndices[col.label] = index;
                });

                // Check for unique image name across all rows
                const imageIndex = columnIndices[this.columnMapping.image];
                if (!imageIndex && imageIndex !== 0) {
                    this.showError("Image column not found");
                    return;
                }

                const uniqueImages = new Set(vaData.data.map(row => row[imageIndex]));
                if (uniqueImages.size === 0) {
                    this.showError("No image name provided");
                    return;
                }
                if (uniqueImages.size > 1) {
                    this.showError("Select an image to view", '', 'neutral');
                    return;
                }

                // Extract the image name from the first row
                const imageName = vaData.data[0][imageIndex];
                if (typeof imageName !== 'string' || !imageName) {
                    this.showError("Invalid image name format", "Image name must be a string");
                    return;
                }

                // Convert VA data to rectangles format using column mapping
                this.rectangles = vaData.data.map(row => ({
                    x: row[columnIndices[this.columnMapping.x]],
                    y: row[columnIndices[this.columnMapping.y]],
                    width: row[columnIndices[this.columnMapping.width]],
                    height: row[columnIndices[this.columnMapping.height]],
                    class: row[columnIndices[this.columnMapping.class]],
                    probability: row[columnIndices[this.columnMapping.probability]],
                    id: row[columnIndices[this.columnMapping.id]],
                    hovered: false
                }));

                // Load the image - this will trigger onload which updates canvas and draws rectangles
                this.loadImage(imageName);
                this.updateDebugPanel();
            }

            // Loads an image from the configured base path
            loadImage(imageName) {
                const fullPath = this.basePath + imageName;
                console.log('Starting to load new image:', fullPath);
                
                // Clear canvas while loading
                this.canvas.getContext('2d').clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.image.style.display = 'none';
                this.shadowRoot.querySelector('#toolbar').classList.add('hidden');
                
                // Reset zoom and position before loading new image
                this.zoomLevel = 1;
                this.imageX = 0;
                this.imageY = 0;
                
                // Add load event listener before setting src
                this.image.onload = () => {
                    console.log('Image loaded:', fullPath);
                    
                    // Hide error message if it was showing
                    this.errorMessage.style.display = 'none';
                    
                    // Show image and toolbar on successful load
                    this.image.style.display = 'block';
                    this.shadowRoot.querySelector('#toolbar').classList.remove('hidden');
                    
                    // Update the view
                    requestAnimationFrame(() => {
                        this.updateCanvasSize();
                        this.drawRectangles();
                        this.updateImageTransform(true);
                        this.updateZoomSlider();
                    });
                };
                
                // Add error handler for this specific load attempt
                this.image.onerror = (e) => {
                    // Show error message with failed image info
                    this.showError("Failed loading image", e.target.src, 'error');
                    
                    // Clear canvas and hide toolbar
                    this.canvas.getContext('2d').clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.shadowRoot.querySelector('#toolbar').classList.add('hidden');
                };
                
                // Always set src to trigger load/error event
                this.image.src = fullPath;
                
                // Force reload by clearing src if it's the same URL
                if (this.image.src === fullPath) {
                    this.image.src = '';
                    this.image.src = fullPath;
                }
            }

            // Updates the base path for image loading
            setBasePath(path) {
                this.basePath = path.endsWith('/') ? path : path + '/';
                if (this.image.src) {
                    const currentImage = this.image.src.split('/').pop();
                    this.loadImage(currentImage);
                }
            }

            // Updates the debug panel with current state information
            updateDebugPanel() {
                if (this.debugPanel) {
                    const debugInfo = `
                        <div>Zoom Level: ${this.zoomLevel}</div>
                        <div>Image X: ${this.imageX}</div>
                        <div>Image Y: ${this.imageY}</div>
                        <div>Image Width: ${this.image.clientWidth}</div>
                        <div>Image Height: ${this.image.clientHeight}</div>
                        <div>Canvas Width: ${this.canvas.width}</div>
                        <div>Canvas Height: ${this.canvas.height}</div>
                        ${this.rectangles.map((rect, index) => `
                            <div>Rectangle ${index + 1} - X: ${rect.x}, Y: ${rect.y}, Width: ${rect.width}, Height: ${rect.height}, Hovered: ${rect.hovered}, Class: ${rect.class}, Probability: ${(rect.probability * 100).toFixed(1)}%</div>
                        `).join('')}
                    `;
                    this.debugPanel.innerHTML = debugInfo;
                }
            }

            // Handles mouse wheel events for zooming
            handleWheel(event) {
                if (this.disableInteraction) return;
                event.preventDefault();
                if (event.deltaY < 0) {
                    this.zoomIn();
                } else {
                    this.zoomOut();
                }
                this.updateDebugPanel();
            }

            // Updates canvas dimensions and scaling based on image size and device pixel ratio
            updateCanvasSize() {
                const dpr = window.devicePixelRatio || 1;
                
                // Get container dimensions
                const container = this.shadowRoot.querySelector('#image-container');
                const containerRect = container.getBoundingClientRect();
                
                // Calculate the scaling factor to fit the image in the container
                const scaleWidth = containerRect.width / this.image.naturalWidth;
                const scaleHeight = containerRect.height / this.image.naturalHeight;
                const scale = Math.min(scaleWidth, scaleHeight);
                
                // Calculate base dimensions maintaining aspect ratio
                const baseWidth = this.image.naturalWidth * scale;
                const baseHeight = this.image.naturalHeight * scale;
                
                console.log('updateCanvasSize - Input values:', {
                    containerDimensions: {
                        width: containerRect.width,
                        height: containerRect.height
                    },
                    naturalDimensions: {
                        width: this.image.naturalWidth,
                        height: this.image.naturalHeight
                    },
                    scale,
                    dpr,
                    zoomLevel: this.zoomLevel
                });
                
                // Set canvas size using base dimensions
                this.canvas.width = baseWidth * dpr;
                this.canvas.height = baseHeight * dpr;
                
                // Set display size
                this.canvas.style.width = `${baseWidth}px`;
                this.canvas.style.height = `${baseHeight}px`;
                
                // Update image size to match canvas
                this.image.style.width = `${baseWidth}px`;
                this.image.style.height = `${baseHeight}px`;
                
                console.log('updateCanvasSize - Calculated values:', {
                    baseWidth,
                    baseHeight,
                    canvasWidth: this.canvas.width,
                    canvasHeight: this.canvas.height,
                    canvasStyleWidth: this.canvas.style.width,
                    canvasStyleHeight: this.canvas.style.height
                });
                
                const ctx = this.canvas.getContext('2d');
                ctx.scale(dpr, dpr);
                ctx.imageSmoothingEnabled = false;
                
                this.drawRectangles();
                this.updateImageTransform(true);
                this.updateDebugPanel();
            }

            // Returns a color for a class name, using predefined colors or fallback colors
            getColorForClass(className) {
                // Check if we already have a color for this class
                if (this.colorCache.has(className)) {
                    return this.colorCache.get(className);
                }

                let color;
                // Check if we have a predefined color for this class
                if (className in this.predefinedColors) {
                    color = this.predefinedColors[className];
                } else {
                    // Use the next fallback color
                    color = this.fallbackColors[this.nextFallbackColorIndex];
                    this.nextFallbackColorIndex = (this.nextFallbackColorIndex + 1) % this.fallbackColors.length;
                }

                // Cache the color for this class
                this.colorCache.set(className, color);
                return color;
            }

            // Renders all bounding box rectangles on the canvas
            drawRectangles() {
                const ctx = this.canvas.getContext('2d');
                const dpr = window.devicePixelRatio || 1;
                
                // Clear the entire canvas
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Reset transform and scale for DPR
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                
                // Get the actual displayed dimensions of the canvas
                const displayedWidth = this.canvas.width / dpr;
                const displayedHeight = this.canvas.height / dpr;

                this.rectangles.forEach(rect => {
                    // Convert normalized coordinates (0-1) to actual pixel coordinates
                    const scaledX = rect.x * displayedWidth;
                    const scaledY = rect.y * displayedHeight;
                    const scaledWidth = rect.width * displayedWidth;
                    const scaledHeight = rect.height * displayedHeight;

                    const borderWidth = 2;
                    const color = this.getColorForClass(rect.class);
                    
                    // Align to pixel grid
                    const x = Math.round(scaledX);
                    const y = Math.round(scaledY);
                    const width = Math.round(scaledWidth);
                    const height = Math.round(scaledHeight);
                    
                    // Draw box
                    ctx.lineWidth = borderWidth;
                    ctx.strokeStyle = color;
                    ctx.fillStyle = rect.hovered ? `${color.replace('rgb', 'rgba').replace(')', ', 0.3)')}` : 'rgba(0, 0, 0, 0)';
                    
                    // Use path for crisp edges
                    ctx.beginPath();
                    ctx.rect(x, y, width, height);
                    ctx.fill();
                    ctx.stroke();

                    // Draw label if hovered
                    if (rect.hovered) {
                        const fontSize = 14;
                        const labelText = `${rect.class}: ${(rect.probability * 100).toFixed(1)}%`;
                        ctx.font = `${fontSize}px Arial`;
                        ctx.textBaseline = 'middle';
                        const textMetrics = ctx.measureText(labelText);
                        const padding = 4;
                        const labelWidth = Math.round(textMetrics.width + (padding * 2));
                        const labelHeight = fontSize + (padding * 2);

                        const labelX = x;
                        const labelY = y - labelHeight - borderWidth;

                        // Draw label background
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.rect(labelX, labelY + 1, labelWidth, labelHeight);
                        ctx.fill();
                        ctx.stroke();

                        // Draw text
                        ctx.fillStyle = 'white';
                        ctx.textAlign = 'left';
                        ctx.fillText(
                            labelText,
                            Math.round(labelX + padding),
                            Math.round(labelY + (labelHeight / 2) + 1)
                        );
                    }
                });
            }

            // Handles mouse hover events over the canvas and updates rectangle hover states
            handleCanvasHover(event) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
                
                // Convert mouse coordinates to normalized coordinates (0-1)
                const relativeX = mouseX / rect.width;
                const relativeY = mouseY / rect.height;

                let hoveredAny = false;
                this.rectangles.forEach(rect => {
                    // Compare with normalized coordinates
                    const centerX = rect.x;
                    const centerY = rect.y;
                    
                    if (relativeX >= centerX && 
                        relativeX <= centerX + rect.width && 
                        relativeY >= centerY && 
                        relativeY <= centerY + rect.height) {
                        rect.hovered = true;
                        hoveredAny = true;
                    } else {
                        rect.hovered = false;
                    }
                });

                this.drawRectangles();
                this.updateDebugPanel();
                
                // Adding hover-specific details to the debug panel
                if (this.debugPanel) {
                    const hoverInfo = `
                        <div>Relative Hover X: ${relativeX.toFixed(3)}</div>
                        <div>Relative Hover Y: ${relativeY.toFixed(3)}</div>
                        <div>Pixel Hover X: ${mouseX.toFixed(2)}</div>
                        <div>Pixel Hover Y: ${mouseY.toFixed(2)}</div>
                    `;
                    this.debugPanel.innerHTML += hoverInfo;
                }
            }

            // Increases zoom level by a fixed increment
            zoomIn() {
                if (this.disableInteraction) return;
                this.zoomLevel = Math.min(3, this.zoomLevel + 0.15);
                this.updateZoomSlider();
                this.updateImageTransform(true);
                this.updateDebugPanel();
            }

            // Decreases zoom level by a fixed increment
            zoomOut() {
                if (this.disableInteraction) return;
                this.zoomLevel = Math.max(0.2, this.zoomLevel - 0.15);
                this.updateZoomSlider();
                this.updateImageTransform(true);
                this.updateDebugPanel();
            }

            // Updates zoom level based on slider value
            sliderZoom() {
                if (this.disableInteraction) return;
                this.zoomLevel = this.zoomSlider.value / 100;
                this.updateImageTransform(false);
                this.updateDebugPanel();
            }

            // Fits the image to the container while maintaining aspect ratio
            maximize() {
                if (this.disableInteraction) return;
                const containerWidth = this.shadowRoot.querySelector('#image-container').clientWidth;
                const containerHeight = this.shadowRoot.querySelector('#image-container').clientHeight;
                const imageWidth = this.image.clientWidth;
                const imageHeight = this.image.clientHeight;

                const widthScale = containerWidth / imageWidth;
                const heightScale = containerHeight / imageHeight;

                this.zoomLevel = Math.max(widthScale, heightScale);
                this.updateZoomSlider();
                this.updateImageTransform(true);
                this.updateDebugPanel();
            }

            // Resets zoom and position to default values
            minimize() {
                if (this.disableInteraction) return;
                this.zoomLevel = 1;
                this.imageX = 0;
                this.imageY = 0;
                this.updateZoomSlider();
                this.updateImageTransform(true);
                this.updateDebugPanel();
            }

            // Initiates image dragging operation
            startDrag(event) {
                if (this.disableInteraction) return;
                this.isDragging = true;
                this.startX = event.clientX - this.imageX;
                this.startY = event.clientY - this.imageY;
                this.image.classList.remove('smooth');
                this.canvas.classList.remove('smooth');
                event.preventDefault();
                this.updateDebugPanel();
            }

            // Updates image position during drag operation
            drag(event) {
                if (!this.isDragging) return;

                this.imageX = event.clientX - this.startX;
                this.imageY = event.clientY - this.startY;
                this.updateImageTransform(false);
                this.updateDebugPanel();
            }

            // Completes drag operation and restores smooth transitions
            endDrag() {
                this.isDragging = false;
                this.image.classList.add('smooth');
                this.canvas.classList.add('smooth');
                this.updateDebugPanel();
            }

            // Synchronizes zoom slider UI with current zoom level
            updateZoomSlider() {
                this.zoomSlider.value = this.zoomLevel * 100;
            }

            // Updates image and canvas transform properties for zoom and pan
            updateImageTransform(smooth) {
                const transformValue = `translate(-50%, -50%) scale(${this.zoomLevel}) translate(${this.imageX / this.zoomLevel}px, ${this.imageY / this.zoomLevel}px)`;
                if (smooth) {
                    this.image.classList.add('smooth');
                    this.canvas.classList.add('smooth');
                } else {
                    this.image.classList.remove('smooth');
                    this.canvas.classList.remove('smooth');
                }
                this.image.style.transform = transformValue;
                this.canvas.style.transform = transformValue;
                
                this.drawRectangles();
                this.updateDebugPanel();
            }

            // Enables or disables user interaction with the viewer
            setDisableInteraction(disabled) {
                this.disableInteraction = disabled;
                const toolbar = this.shadowRoot.querySelector('#toolbar');
                if (disabled) {
                    toolbar.classList.add('hidden');
                    // Reset zoom and position when disabling interaction
                    this.zoomLevel = 1;
                    this.imageX = 0;
                    this.imageY = 0;
                    this.updateImageTransform(true);
                } else {
                    toolbar.classList.remove('hidden');
                }
            }

            // Updates the mapping explanations based on current column mapping
            updateMappingExplanations() {
                const mappingDetails = this.shadowRoot.querySelector('.mapping-details');
                const explanations = {
                    image: 'Name of the image file in the dataset',
                    x: 'Center X-coordinate of the bounding box (normalized 0-1)',
                    y: 'Center Y-coordinate of the bounding box (normalized 0-1)',
                    width: 'Width of the bounding box relative to image width (normalized 0-1)',
                    height: 'Height of the bounding box relative to image height (normalized 0-1)',
                    class: 'Classification label of the detected object',
                    probability: 'Confidence score of the detection (0-1)',
                    id: 'Unique numerical identifier for each detection'
                };

                mappingDetails.innerHTML = Object.entries(this.columnMapping)
                    .map(([key, label]) => `
                        <div class="mapping-row">
                            <div class="mapping-label">${label}</div>
                            <div class="mapping-description">${explanations[key]}</div>
                        </div>
                    `).join('');
            }
        }

        customElements.define('bbox-viewer-app', BboxViewerApp);
    </script>
</body>
</html>